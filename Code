1. Write a program to calculate the Factorial of a number using recursive and non- recursive method
#include <iostream>
using namespace std;
int factorialRecursive(int n)
{
    if (n == 0)
        return 1;
    return n * factorialRecursive(n - 1);
}
int factorialNonRecursive(int n)
{
    int result = 1;
    for (int i = 1; i <= n; i++)
    {
        result *= i;
    }
    return result;
}

int main()
{
    int num;
    cin >> num;

    if (num < 0)
    {

        return 1;
    }
    int factRecursive = factorialRecursive(num);
    cout << "Factorial (Recursive): " << factRecursive << endl;
    int factNonRecursive = factorialNonRecursive(num);
    cout << "Factorial (Non-Recursive): " << factNonRecursive << endl;

    return 0;
}
2. Write a program to find the nth term F1 of the Fibonacci sequence using recursive and non-recursive method.
#include <iostream>
using namespace std;
int fibonacciRecursive(int n)
{
    if (n == 0)
        return 0;
    if (n == 1)
        return 1;
    return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
}
int fibonacciNonRecursive(int n)
{
    if (n == 0)
        return 0;
    if (n == 1)
        return 1;

    int a = 0, b = 1, fib = 0;
    for (int i = 2; i <= n; i++)
    {
        fib = a + b;
        a = b;
        b = fib;
    }
    return fib;
}

int main()
{
    int n;
    cin >> n;

    if (n < 0)
    {

        return 1;
    }

    int fibRecursive = fibonacciRecursive(n);
    cout << "Fibonacci (Recursive): " << fibRecursive << endl;

    int fibNonRecursive = fibonacciNonRecursive(n);
    cout << "Fibonacci (Non-Recursive): " << fibNonRecursive << endl;

    return 0;
}
3. Tower of Hanoi Problem
#include <iostream>
using namespace std;
void towerOfHanoi(int n, char source, char destination, char auxiliary)
{
    if (n == 1)
    {
        cout << "Move disk 1 from " << source << " to " << destination << endl;
        return;
    }
    towerOfHanoi(n - 1, source, auxiliary, destination);
    cout << "Move disk " << n << " from " << source << " to " << destination << endl;
    towerOfHanoi(n - 1, auxiliary, destination, source);
}
int main()
{
    int n;
    cout << "Enter the number of disks: ";
    cin >> n;
    towerOfHanoi(n, 'A', 'C', 'B');

    return 0;
}
4. Ackermann Function
#include <iostream>
using namespace std;
int ackermann(int m, int n)
{
    if (m == 0)
        return n + 1;
    else if (n == 0)
        return ackermann(m - 1, 1);
    else
        return ackermann(m - 1, ackermann(m, n - 1));
}
int main()
{
    int m, n;
    cin >> m >> n;
    int result = ackermann(m, n);
    cout << "Ackermann(" << m << ", " << n << ") = " << result << endl;
    return 0;
}
5. Binary Search Tree (BST) Creation,Traversal,Search,Delete
#include <iostream>
using namespace std;
struct Node
{
    int data;
    Node* left;
    Node* right;
};
Node* createNode(int value)
{
    Node* newNode = new Node();
    newNode->data = value;
    newNode->left = newNode->right = nullptr;
    return newNode;
}
Node* insert(Node* root, int value)
{
    if (root == nullptr)
        return createNode(value);

    if (value < root->data)
        root->left = insert(root->left, value);
    else
        root->right = insert(root->right, value);

    return root;
}
void inorder(Node* root)
{
    if (root != nullptr)
    {
        inorder(root->left);
        cout << root->data << " ";
        inorder(root->right);
    }
}
void preorder(Node* root)
{
    if (root != nullptr)
    {
        cout << root->data << " ";
        preorder(root->left);
        preorder(root->right);
    }
}
void postorder(Node* root)
{
    if (root != nullptr)
    {
        postorder(root->left);
        postorder(root->right);
        cout << root->data << " ";
    }
}
bool search(Node* root, int key)
{
    if (root == nullptr)
        return false;

    if (root->data == key)
        return true;

    if (key < root->data)
        return search(root->left, key);

    return search(root->right, key);
}
Node* findMin(Node* root)
{
    while (root->left != nullptr)
        root = root->left;
    return root;
}

Node* deleteNode(Node* root, int key)
{
    if (root == nullptr)
        return root;

    if (key < root->data)
        root->left = deleteNode(root->left, key);
    else if (key > root->data)
        root->right = deleteNode(root->right, key);
    else
    {
        if (root->left == nullptr)
        {
            Node* temp = root->right;
            delete root;
            return temp;
        }
        else if (root->right == nullptr)
        {
            Node* temp = root->left;
            delete root;
            return temp;
        }
        Node* temp = findMin(root->right);
        root->data = temp->data;
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}
int main()
{
    Node* root = nullptr;
    int n, value;
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        cin >> value;
        root = insert(root, value);
    }
    cout << "Inorder Traversal: ";
    inorder(root);
    cout << endl;
    cout << "Preorder Traversal: ";
    preorder(root);
    cout << endl;
    cout << "Postorder Traversal: ";
    postorder(root);
    cout << endl;
    int key1;
    cin>>key1;
    if (search(root, key1))
        cout << "Value found in the BST" << endl;
    else
        cout << "Value not found in the BST" << endl;
    int key2;
    cin>>key2;
    root = deleteNode(root, key2);
    inorder(root);
    cout << endl;
    return 0;
}
8.Create a Maxheap and Display its Elements  and Delete an Element
#include <iostream>
#include <vector>
using namespace std;

void heapifyUp(vector<int>& heap, int index)
{
    while (index > 0)
    {
        int parent = (index - 1) / 2;
        if (heap[index] > heap[parent])
        {
            swap(heap[index], heap[parent]);
            index = parent;
        }
        else
        {
            break;
        }
    }
}

void heapifyDown(vector<int>& heap, int index)
{
    int size = heap.size();
    while (true)
    {
        int leftChild = 2 * index + 1;
        int rightChild = 2 * index + 2;
        int largest = index;
        if (leftChild < size && heap[leftChild] > heap[largest])
            largest = leftChild;
        if (rightChild < size && heap[rightChild] > heap[largest])
            largest = rightChild;
        if (largest == index) break;
        swap(heap[index], heap[largest]);
        index = largest;
    }
}

void insert(vector<int>& heap, int value)
{
    heap.push_back(value);
    heapifyUp(heap, heap.size() - 1);
}

void deleteelement(vector<int>& heap, int index)
{
    if (index < 0 || index >= heap.size())
    {
        cout << "Invalid index!\n";
        return;
    }

    heap[index] = heap.back();
    heap.pop_back();            

    heapifyDown(heap, index);   
    heapifyUp(heap, index);     
}
void display(vector<int>& heap)
{
    for (int i = 0; i < heap.size(); i++)
    {
        cout << heap[i] << " ";
    }
    cout << endl;
}

int main()
{
    vector<int> heap;
    int n, value, index;
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        cin >> value;
        insert(heap, value);
    }
    display(heap);
    cin >> index;
    deleteelement(heap, index);
    display(heap);
    return 0;
}
9. Heap Sort Algorithm
#include <iostream>
#include <vector>
using namespace std;
void heapify(vector<int>& heap, int n, int i)
{
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    if (left < n && heap[left] > heap[largest])
        largest = left;
    if (right < n && heap[right] > heap[largest])
        largest = right;
    if (largest != i)
    {
        swap(heap[i], heap[largest]);
        heapify(heap, n, largest);
    }
}
void heapSort(vector<int>& heap)
{
    int n = heap.size();
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(heap, n, i);
    for (int i = n - 1; i >= 1; i--)
    {
        swap(heap[0], heap[i]);
        heapify(heap, i, 0);
    }
}
void display(const vector<int>& heap)
{
    for (int val : heap)
        cout << val << " ";
    cout << endl;
}
int main()
{
    int n;
    cin >> n;

    vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        cin >> nums[i];
    }
    heapSort(nums);
    display(nums);
    return 0;
}
11. Display the Adjacency Matrix of a Graph
Explanation:
An Adjacency Matrix is a 2D array used to represent a graph. The rows and columns represent the vertices, and the value at matrix[i][j] indicates whether there is an edge from vertex i to vertex j.

For an undirected graph, if there is an edge between vertices i and j, both matrix[i][j] and matrix[j][i] are 1.
For a directed graph, only matrix[i][j] is 1 if there is an edge from i to j.
C++ Code for Adjacency Matrix:
cpp
Copy code
#include <iostream>
#include <vector>
using namespace std;

class Graph {
    int vertices;
    vector<vector<int>> adjMatrix;

public:
    Graph(int v) : vertices(v) {
        adjMatrix.resize(vertices, vector<int>(vertices, 0));  // Initialize matrix with 0s
    }

    void addEdge(int u, int v) {
        adjMatrix[u][v] = 1;  // For directed graph
        adjMatrix[v][u] = 1;  // For undirected graph
    }

    void displayAdjMatrix() {
        cout << "Adjacency Matrix: " << endl;
        for (int i = 0; i < vertices; i++) {
            for (int j = 0; j < vertices; j++) {
                cout << adjMatrix[i][j] << " ";
            }
            cout << endl;
        }
    }
};

int main() {
    int n, e, u, v;
    cout << "Enter the number of vertices: ";
    cin >> n;

    Graph g(n);

    cout << "Enter the number of edges: ";
    cin >> e;

    cout << "Enter the edges (u v):" << endl;
    for (int i = 0; i < e; i++) {
        cin >> u >> v;
        g.addEdge(u, v);
    }

    g.displayAdjMatrix();

    return 0;
}
Explanation:
addEdge(u, v): Adds an edge between vertices u and v by setting the corresponding matrix elements.
displayAdjMatrix(): Prints the adjacency matrix row by row.
12. Display the Adjacency List of a Graph
Explanation:
An Adjacency List is an array of lists where each index represents a vertex, and each list stores the vertices adjacent to that vertex. This representation is more space-efficient for sparse graphs.

C++ Code for Adjacency List:
cpp
Copy code
#include <iostream>
#include <vector>
#include <list>
using namespace std;

class Graph {
    int vertices;
    vector<list<int>> adjList;

public:
    Graph(int v) : vertices(v) {
        adjList.resize(vertices);
    }

    void addEdge(int u, int v) {
        adjList[u].push_back(v);  // For directed graph
        adjList[v].push_back(u);  // For undirected graph
    }

    void displayAdjList() {
        cout << "Adjacency List: " << endl;
        for (int i = 0; i < vertices; i++) {
            cout << i << ": ";
            for (auto v : adjList[i]) {
                cout << v << " ";
            }
            cout << endl;
        }
    }
};

int main() {
    int n, e, u, v;
    cout << "Enter the number of vertices: ";
    cin >> n;

    Graph g(n);

    cout << "Enter the number of edges: ";
    cin >> e;

    cout << "Enter the edges (u v):" << endl;
    for (int i = 0; i < e; i++) {
        cin >> u >> v;
        g.addEdge(u, v);
    }

    g.displayAdjList();

    return 0;
}
Explanation:
addEdge(u, v): Adds an edge between u and v by appending v to the adjacency list of u (and vice versa for undirected graphs).
displayAdjList(): Prints the adjacency list by traversing the list of each vertex.
Example Input/Output:
Input for Adjacency Matrix:
mathematica
Copy code
Enter the number of vertices: 4
Enter the number of edges: 4
Enter the edges (u v):
0 1
0 2
1 2
2 3
Output for Adjacency Matrix:
yaml
Copy code
Adjacency Matrix:
0 1 1 0 
1 0 1 0 
1 1 0 1 
0 0 1 0 
Input for Adjacency List:
mathematica
Copy code
Enter the number of vertices: 4
Enter the number of edges: 4
Enter the edges (u v):
0 1
0 2
1 2
2 3
Output for Adjacency List:
yaml
Copy code
Adjacency List:
0: 1 2 
1: 0 2 
2: 0 1 3 
3: 2 
This code provides an efficient way to represent and display both the adjacency matrix and adjacency list of a graph.






You said:
13. Write a program to traverse a graph using Breadth First Search.
14. Write a program to traverse a graph using Depth First Search.
15. Write a program to determine the value of the nth Fibonacci number Fn where Fn
= Fn-1+ Fn-2 and F1 F2 = 1 and n<=500.
ChatGPT said:
ChatGPT
13. Breadth First Search (BFS) Traversal
Explanation:
Breadth First Search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at a given node (root) and explores all the neighbors at the present depth level before moving on to nodes at the next depth level. BFS uses a queue to keep track of the nodes to visit.

C++ Code for BFS:
cpp
Copy code
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

class Graph {
    int vertices;
    vector<vector<int>> adjList;

public:
    Graph(int v) : vertices(v) {
        adjList.resize(vertices);
    }

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        adjList[v].push_back(u);  // For undirected graph
    }

    void BFS(int start) {
        vector<bool> visited(vertices, false);
        queue<int> q;
        visited[start] = true;
        q.push(start);

        cout << "BFS Traversal: ";
        while (!q.empty()) {
            int node = q.front();
            q.pop();
            cout << node << " ";

            for (int neighbor : adjList[node]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    q.push(neighbor);
                }
            }
        }
        cout << endl;
    }
};

int main() {
    int n, e, u, v, start;
    cout << "Enter the number of vertices: ";
    cin >> n;

    Graph g(n);

    cout << "Enter the number of edges: ";
    cin >> e;

    cout << "Enter the edges (u v):" << endl;
    for (int i = 0; i < e; i++) {
        cin >> u >> v;
        g.addEdge(u, v);
    }

    cout << "Enter the starting vertex for BFS: ";
    cin >> start;

    g.BFS(start);

    return 0;
}
Explanation of BFS:
addEdge(u, v): Adds an edge between vertices u and v.
BFS(start): Performs BFS traversal starting from vertex start using a queue.
14. Depth First Search (DFS) Traversal
Explanation:
Depth First Search (DFS) is an algorithm for traversing or searching tree or graph data structures. Starting at the root (or any arbitrary node), DFS explores as far as possible along each branch before backtracking. DFS can be implemented using recursion or using an explicit stack.

C++ Code for DFS:
cpp
Copy code
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

class Graph {
    int vertices;
    vector<vector<int>> adjList;

public:
    Graph(int v) : vertices(v) {
        adjList.resize(vertices);
    }

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        adjList[v].push_back(u);  // For undirected graph
    }

    void DFS(int start) {
        vector<bool> visited(vertices, false);
        stack<int> s;
        s.push(start);

        cout << "DFS Traversal: ";
        while (!s.empty()) {
            int node = s.top();
            s.pop();

            if (!visited[node]) {
                visited[node] = true;
                cout << node << " ";
            }

            // Add all unvisited neighbors to the stack
            for (int neighbor : adjList[node]) {
                if (!visited[neighbor]) {
                    s.push(neighbor);
                }
            }
        }
        cout << endl;
    }
};

int main() {
    int n, e, u, v, start;
    cout << "Enter the number of vertices: ";
    cin >> n;

    Graph g(n);

    cout << "Enter the number of edges: ";
    cin >> e;

    cout << "Enter the edges (u v):" << endl;
    for (int i = 0; i < e; i++) {
        cin >> u >> v;
        g.addEdge(u, v);
    }

    cout << "Enter the starting vertex for DFS: ";
    cin >> start;

    g.DFS(start);

    return 0;
}
Explanation of DFS:
addEdge(u, v): Adds an edge between vertices u and v.
DFS(start): Performs DFS traversal starting from vertex start using a stack.
15. Fibonacci Sequence for nth Fibonacci Number
Explanation:
The Fibonacci Sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The nth Fibonacci number can be computed using dynamic programming or recursion. For large n, we can use an iterative approach to avoid stack overflow or excessive recursion calls.

C++ Code for Fibonacci Calculation:
cpp
Copy code
#include <iostream>
#include <vector>
using namespace std;

class Fibonacci {
public:
    // Method to calculate the nth Fibonacci number
    int fibonacci(int n) {
        if (n <= 1) return 1;  // F1 and F2 are 1

        int a = 1, b = 1, result;
        for (int i = 2; i <= n; i++) {
            result = a + b;
            a = b;
            b = result;
        }
        return result;
    }
};

int main() {
    int n;
    cout << "Enter the value of n (n <= 500): ";
    cin >> n;

    if (n > 500) {
        cout << "n should be less than or equal to 500." << endl;
        return 1;
    }

    Fibonacci fib;
    cout << "Fibonacci(" << n << ") = " << fib.fibonacci(n) << endl;

    return 0;
}
Explanation of Fibonacci Calculation:
The fibonacci(n) method uses an iterative approach to calculate the nth Fibonacci number.
We initialize two variables a and b to 1 (F1 and F2).
We then loop from 2 to n, updating a and b to the next Fibonacci numbers.
Example Input/Output:
BFS Example:
Input:

mathematica
Copy code
Enter the number of vertices: 5
Enter the number of edges: 4
Enter the edges (u v):
0 1
0 2
1 3
2 4
Enter the starting vertex for BFS: 0
Output:

yaml
Copy code
BFS Traversal: 0 1 2 3 4
DFS Example:
Input:

mathematica
Copy code
Enter the number of vertices: 5
Enter the number of edges: 4
Enter the edges (u v):
0 1
0 2
1 3
2 4
Enter the starting vertex for DFS: 0
Output:

yaml
Copy code
DFS Traversal: 0 2 4 1 3
Fibonacci Example:
Input:

java
Copy code
Enter the value of n (n <= 500): 10
Output:

scss
Copy code
Fibonacci(10) = 89
This code provides a simple, efficient solution for BFS, DFS, and Fibonacci number calculation up to n = 500.
